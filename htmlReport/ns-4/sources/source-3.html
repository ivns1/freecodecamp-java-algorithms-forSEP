


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > SplayTreeRun</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.williamfiset.algorithms.datastructures.binarysearchtree</a>
</div>

<h1>Coverage Summary for Class: SplayTreeRun (com.williamfiset.algorithms.datastructures.binarysearchtree)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SplayTreeRun</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/28)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;// javac -d classes -sourcepath src/main/java
&nbsp;// src/main/java/com/williamfiset/algorithms/datastructures/binarysearchtree/SplayTree.java
&nbsp;// java -cp classes com.williamfiset.algorithms.datastructures.binarysearchtree.SplayTreeRun
&nbsp;
&nbsp;package com.williamfiset.algorithms.datastructures.binarysearchtree;
&nbsp;
&nbsp;import com.williamfiset.algorithms.datastructures.utils.TreePrinter;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Scanner;
&nbsp;
&nbsp;/**
&nbsp; * Standard Splay Tree Implementation, supports generic data(must implement Comparable)
&nbsp; *
&nbsp; * &lt;p&gt;The Basic Concept of SplayTree is to keep frequently used nodes close to the root of the tree
&nbsp; * It performs basic operations such as insertion,search,delete,findMin,findMax in O(log n)
&nbsp; * amortized time Having frequently-used nodes near to the root can be useful in implementing many
&nbsp; * algorithms. e.g: Implementing caches, garbage collection algorithms etc Primary disadvantage of
&nbsp; * the splay tree can be the fact that its height can go linear. This causes the worst case running
&nbsp; * times to go O(n) However, the amortized costs of this worst case situation is logarithmic, O(log
&nbsp; * n)
&nbsp; *
&nbsp; * @author Ashiqur Rahman,https://github.com/ashiqursuperfly
&nbsp; */
&nbsp;public class SplayTree&lt;T extends Comparable&lt;T&gt;&gt; {
&nbsp;
&nbsp;  private BinaryTree&lt;T&gt; root;
&nbsp;
&nbsp;  public static class BinaryTree&lt;T extends Comparable&lt;T&gt;&gt; implements TreePrinter.PrintableNode {
&nbsp;    private T data;
&nbsp;    private BinaryTree&lt;T&gt; leftChild, rightChild;
&nbsp;
&nbsp;    public BinaryTree(T data) {
&nbsp;      if (data == null) {
&nbsp;        try {
&nbsp;          throw new Exception(&quot;Null data not allowed into tree&quot;);
&nbsp;        } catch (Exception e) {
&nbsp;          e.printStackTrace();
&nbsp;        }
&nbsp;      } else this.data = data;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public BinaryTree&lt;T&gt; getLeft() {
&nbsp;      return leftChild;
&nbsp;    }
&nbsp;
&nbsp;    public void setLeft(BinaryTree&lt;T&gt; leftChild) {
&nbsp;      this.leftChild = leftChild;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public BinaryTree&lt;T&gt; getRight() {
&nbsp;      return rightChild;
&nbsp;    }
&nbsp;
&nbsp;    public void setRight(BinaryTree&lt;T&gt; rightChild) {
&nbsp;      this.rightChild = rightChild;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getText() {
&nbsp;      return data.toString();
&nbsp;    }
&nbsp;
&nbsp;    public T getData() {
&nbsp;      return data;
&nbsp;    }
&nbsp;
&nbsp;    public void setData(T data) {
&nbsp;      if (data == null) {
&nbsp;        try {
&nbsp;          throw new Exception(&quot;Null data not allowed into tree&quot;);
&nbsp;        } catch (Exception e) {
&nbsp;          e.printStackTrace();
&nbsp;        }
&nbsp;      } else this.data = data;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String toString() {
&nbsp;
&nbsp;      return TreePrinter.getTreeDisplay(this);
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /** Public Methods * */
&nbsp;  public SplayTree() {
&nbsp;    this.root = null;
&nbsp;  }
&nbsp;
&nbsp;  public SplayTree(BinaryTree&lt;T&gt; root) {
&nbsp;    this.root = root;
&nbsp;  }
&nbsp;
&nbsp;  public BinaryTree&lt;T&gt; getRoot() {
&nbsp;    return root;
&nbsp;  }
&nbsp;
&nbsp;  /** Searches a node and splays it on top,returns the new root * */
&nbsp;  public BinaryTree&lt;T&gt; search(T node) {
&nbsp;    if (root == null) return null;
&nbsp;
&nbsp;    this.root = splayUtil(root, node);
&nbsp;
&nbsp;    return this.root.getData().compareTo(node) == 0 ? this.root : null;
&nbsp;  }
&nbsp;
&nbsp;  /** Inserts a node into the tree and splays it on top, returns the new root* */
&nbsp;  public BinaryTree&lt;T&gt; insert(T node) {
&nbsp;    if (root == null) {
&nbsp;      root = new BinaryTree&lt;&gt;(node);
&nbsp;      return root;
&nbsp;    }
&nbsp;    splay(node);
&nbsp;
&nbsp;    ArrayList&lt;BinaryTree&lt;T&gt;&gt; l_r = split(node);
&nbsp;
&nbsp;    BinaryTree&lt;T&gt; left = l_r.get(0);
&nbsp;    BinaryTree&lt;T&gt; right = l_r.get(1);
&nbsp;
&nbsp;    root = new BinaryTree&lt;&gt;(node);
&nbsp;    root.setLeft(left);
&nbsp;    root.setRight(right);
&nbsp;
&nbsp;    return root;
&nbsp;  }
&nbsp;
&nbsp;  /** Deletes a node,returns the new root * */
&nbsp;  public BinaryTree&lt;T&gt; delete(T node) {
&nbsp;    if (root == null) return null;
&nbsp;
&nbsp;    BinaryTree&lt;T&gt; searchResult = splay(node);
&nbsp;
&nbsp;    if (searchResult.getData().compareTo(node) != 0) return null;
&nbsp;
&nbsp;    BinaryTree&lt;T&gt; leftSubtree = root.getLeft();
&nbsp;    BinaryTree&lt;T&gt; rightSubtree = root.getRight();
&nbsp;
&nbsp;    // Set the &#39;to be deleted&#39; key ready for garbage collection
&nbsp;    root.setLeft(null);
&nbsp;    root.setRight(null);
&nbsp;
&nbsp;    root = join(leftSubtree, rightSubtree);
&nbsp;
&nbsp;    return root;
&nbsp;  }
&nbsp;
&nbsp;  /** To FindMax Of Entire Tree * */
&nbsp;  public T findMax() {
&nbsp;    BinaryTree&lt;T&gt; temp = root;
&nbsp;    while (temp.getRight() != null) temp = temp.getRight();
&nbsp;    return temp.getData();
&nbsp;  }
&nbsp;
&nbsp;  /** To FindMin Of Entire Tree * */
&nbsp;  public T findMin() {
&nbsp;    BinaryTree&lt;T&gt; temp = root;
&nbsp;    while (temp.getLeft() != null) temp = temp.getLeft();
&nbsp;    return temp.getData();
&nbsp;  }
&nbsp;
&nbsp;  /** * To FindMax Of Tree with specified root * */
&nbsp;  public T findMax(BinaryTree&lt;T&gt; root) {
&nbsp;    BinaryTree&lt;T&gt; temp = root;
&nbsp;    while (temp.getRight() != null) temp = temp.getRight();
&nbsp;    return temp.getData();
&nbsp;  }
&nbsp;
&nbsp;  /** * To FindMin Of Tree with specified root * */
&nbsp;  public T findMin(BinaryTree&lt;T&gt; root) {
&nbsp;    BinaryTree&lt;T&gt; temp = root;
&nbsp;    while (temp.getLeft() != null) temp = temp.getLeft();
&nbsp;    return temp.getData();
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public String toString() {
&nbsp;
&nbsp;    System.out.println(&quot;Elements:&quot; + inorder(root, new ArrayList&lt;&gt;()));
&nbsp;    return (root != null) ? root.toString() : null;
&nbsp;  }
&nbsp;
&nbsp;  /** Private Methods * */
&nbsp;  private BinaryTree&lt;T&gt; rightRotate(BinaryTree&lt;T&gt; node) {
&nbsp;    BinaryTree&lt;T&gt; p = node.getLeft();
&nbsp;    node.setLeft(p.getRight());
&nbsp;    p.setRight(node);
&nbsp;    return p;
&nbsp;  }
&nbsp;
&nbsp;  private BinaryTree&lt;T&gt; leftRotate(BinaryTree&lt;T&gt; node) {
&nbsp;    BinaryTree&lt;T&gt; p = node.getRight();
&nbsp;    node.setRight(p.getLeft());
&nbsp;    p.setLeft(node);
&nbsp;    return p;
&nbsp;  }
&nbsp;
&nbsp;  private BinaryTree&lt;T&gt; splayUtil(BinaryTree&lt;T&gt; root, T key) {
&nbsp;    if (root == null || root.getData() == key) return root;
&nbsp;
&nbsp;    if (root.getData().compareTo(key) &gt; 0) {
&nbsp;      if (root.getLeft() == null) return root;
&nbsp;
&nbsp;      if (root.getLeft().getData().compareTo(key) &gt; 0) {
&nbsp;
&nbsp;        root.getLeft().setLeft(splayUtil(root.getLeft().getLeft(), key));
&nbsp;
&nbsp;        root = rightRotate(root);
&nbsp;      } else if (root.getLeft().getData().compareTo(key) &lt; 0) {
&nbsp;
&nbsp;        root.getLeft().setRight(splayUtil(root.getLeft().getRight(), key));
&nbsp;
&nbsp;        if (root.getLeft().getRight() != null) root.setLeft(leftRotate(root.getLeft()));
&nbsp;      }
&nbsp;      return (root.getLeft() == null) ? root : rightRotate(root);
&nbsp;    } else {
&nbsp;      if (root.getRight() == null) return root;
&nbsp;
&nbsp;      if (root.getRight().getData().compareTo(key) &gt; 0) {
&nbsp;        root.getRight().setLeft(splayUtil(root.getRight().getLeft(), key));
&nbsp;        if (root.getRight().getLeft() != null) root.setRight(rightRotate(root.getRight()));
&nbsp;      } else if (root.getRight().getData().compareTo(key) &lt; 0) // Zag-Zag (Right Right)
&nbsp;      {
&nbsp;        root.getRight().setRight(splayUtil(root.getRight().getRight(), key));
&nbsp;        root = leftRotate(root);
&nbsp;      }
&nbsp;
&nbsp;      return (root.getRight() == null) ? root : leftRotate(root);
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private BinaryTree&lt;T&gt; splay(T node) {
&nbsp;    if (root == null) return null;
&nbsp;
&nbsp;    this.root = splayUtil(root, node);
&nbsp;
&nbsp;    return this.root;
&nbsp;  }
&nbsp;
&nbsp;  private ArrayList&lt;BinaryTree&lt;T&gt;&gt; split(T node) {
&nbsp;    BinaryTree&lt;T&gt; right;
&nbsp;    BinaryTree&lt;T&gt; left;
&nbsp;
&nbsp;    if (node.compareTo(root.getData()) &gt; 0) {
&nbsp;      right = root.getRight();
&nbsp;      left = root;
&nbsp;      left.setRight(null);
&nbsp;    } else {
&nbsp;      left = root.getLeft();
&nbsp;      right = root;
&nbsp;      right.setLeft(null);
&nbsp;    }
&nbsp;    ArrayList&lt;BinaryTree&lt;T&gt;&gt; l_r = new ArrayList&lt;&gt;();
&nbsp;    l_r.add(left);
&nbsp;    l_r.add(right);
&nbsp;
&nbsp;    return l_r;
&nbsp;  }
&nbsp;
&nbsp;  private BinaryTree&lt;T&gt; join(BinaryTree&lt;T&gt; L, BinaryTree&lt;T&gt; R) {
&nbsp;
&nbsp;    if (L == null) {
&nbsp;      root = R;
&nbsp;      return R;
&nbsp;    }
&nbsp;    root = splayUtil(L, findMax(L));
&nbsp;    root.setRight(R);
&nbsp;    return root;
&nbsp;  }
&nbsp;
&nbsp;  private ArrayList&lt;T&gt; inorder(BinaryTree&lt;T&gt; root, ArrayList&lt;T&gt; sorted) {
&nbsp;
&nbsp;    if (root == null) {
&nbsp;      return sorted;
&nbsp;    }
&nbsp;    inorder(root.getLeft(), sorted);
&nbsp;    sorted.add(root.getData());
&nbsp;    inorder(root.getRight(), sorted);
&nbsp;    return sorted;
&nbsp;  }
&nbsp;}
&nbsp;
<b class="nc">&nbsp;class SplayTreeRun {</b>
&nbsp;
&nbsp;  public static void main(String[] args) {
&nbsp;
<b class="nc">&nbsp;    SplayTree&lt;Integer&gt; splayTree = new SplayTree&lt;&gt;();</b>
<b class="nc">&nbsp;    Scanner sc = new Scanner(System.in);</b>
<b class="nc">&nbsp;    int[] data = {2, 29, 26, -1, 10, 0, 2, 11};</b>
<b class="nc">&nbsp;    int c = 0;</b>
<b class="nc">&nbsp;    for (int i : data) {</b>
<b class="nc">&nbsp;      splayTree.insert(i);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    while (c != 7) {</b>
<b class="nc">&nbsp;      System.out.println(&quot;1. Insert 2. Delete 3. Search 4.FindMin 5.FindMax 6. PrintTree 7. Exit&quot;);</b>
<b class="nc">&nbsp;      c = sc.nextInt();</b>
<b class="nc">&nbsp;      switch (c) {</b>
&nbsp;        case 1:
<b class="nc">&nbsp;          System.out.println(&quot;Enter Data :&quot;);</b>
<b class="nc">&nbsp;          splayTree.insert(sc.nextInt());</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case 2:
<b class="nc">&nbsp;          System.out.println(&quot;Enter Element to be Deleted:&quot;);</b>
<b class="nc">&nbsp;          splayTree.delete(sc.nextInt());</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case 3:
<b class="nc">&nbsp;          System.out.println(&quot;Enter Element to be Searched and Splayed:&quot;);</b>
<b class="nc">&nbsp;          splayTree.search(sc.nextInt());</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case 4:
<b class="nc">&nbsp;          System.out.println(&quot;Min: &quot; + splayTree.findMin());</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case 5:
<b class="nc">&nbsp;          System.out.println(&quot;Max: &quot; + splayTree.findMax());</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case 6:
<b class="nc">&nbsp;          System.out.println(splayTree);</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;        case 7:
<b class="nc">&nbsp;          sc.close();</b>
<b class="nc">&nbsp;          break;</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-06-22 16:41</div>
</div>
</body>
</html>
