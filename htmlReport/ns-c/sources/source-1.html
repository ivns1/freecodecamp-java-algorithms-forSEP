


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > BinaryHeap</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.williamfiset.algorithms.datastructures.priorityqueue</a>
</div>

<h1>Coverage Summary for Class: BinaryHeap (com.williamfiset.algorithms.datastructures.priorityqueue)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BinaryHeap</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89,5%
  </span>
  <span class="absValue">
    (17/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90,1%
  </span>
  <span class="absValue">
    (64/71)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * A min priority queue implementation using a binary heap.
&nbsp; *
&nbsp; * @author William Fiset, william.alexandre.fiset@gmail.com
&nbsp; */
&nbsp;package com.williamfiset.algorithms.datastructures.priorityqueue;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.List;
&nbsp;
&nbsp;public class BinaryHeap&lt;T extends Comparable&lt;T&gt;&gt; {
&nbsp;
&nbsp;  // A dynamic list to track the elements inside the heap
<b class="fc">&nbsp;  private List&lt;T&gt; heap = null;</b>
&nbsp;
&nbsp;  // Construct and initially empty priority queue
&nbsp;  public BinaryHeap() {
<b class="fc">&nbsp;    this(1);</b>
&nbsp;  }
&nbsp;
&nbsp;  // Construct a priority queue with an initial capacity
<b class="fc">&nbsp;  public BinaryHeap(int sz) {</b>
<b class="fc">&nbsp;    heap = new ArrayList&lt;&gt;(sz);</b>
&nbsp;  }
&nbsp;
&nbsp;  // Construct a priority queue using heapify in O(n) time, a great explanation can be found at:
&nbsp;  // http://www.cs.umd.edu/~meesh/351/mount/lectures/lect14-heapsort-analysis-part.pdf
<b class="fc">&nbsp;  public BinaryHeap(T[] elems) {</b>
&nbsp;
<b class="fc">&nbsp;    int heapSize = elems.length;</b>
<b class="fc">&nbsp;    heap = new ArrayList&lt;T&gt;(heapSize);</b>
&nbsp;
&nbsp;    // Place all element in heap
<b class="fc">&nbsp;    for (int i = 0; i &lt; heapSize; i++) heap.add(elems[i]);</b>
&nbsp;
&nbsp;    // Heapify process, O(n)
<b class="fc">&nbsp;    for (int i = Math.max(0, (heapSize / 2) - 1); i &gt;= 0; i--) sink(i);</b>
&nbsp;  }
&nbsp;
&nbsp;  // Priority queue construction, O(n)
<b class="nc">&nbsp;  public BinaryHeap(Collection&lt;T&gt; elems) {</b>
&nbsp;
<b class="nc">&nbsp;    int heapSize = elems.size();</b>
<b class="nc">&nbsp;    heap = new ArrayList&lt;T&gt;(heapSize);</b>
&nbsp;
&nbsp;    // Add all elements of the given collection to the heap
<b class="nc">&nbsp;    heap.addAll(elems);</b>
&nbsp;
&nbsp;    // Heapify process, O(n)
<b class="nc">&nbsp;    for (int i = Math.max(0, (heapSize / 2) - 1); i &gt;= 0; i--) sink(i);</b>
&nbsp;  }
&nbsp;
&nbsp;  // Returns true/false depending on if the priority queue is empty
&nbsp;  public boolean isEmpty() {
<b class="fc">&nbsp;    return size() == 0;</b>
&nbsp;  }
&nbsp;
&nbsp;  // Clears everything inside the heap, O(n)
&nbsp;  public void clear() {
<b class="fc">&nbsp;    heap.clear();</b>
&nbsp;  }
&nbsp;
&nbsp;  // Return the size of the heap
&nbsp;  public int size() {
<b class="fc">&nbsp;    return heap.size();</b>
&nbsp;  }
&nbsp;
&nbsp;  // Returns the value of the element with the lowest
&nbsp;  // priority in this priority queue. If the priority
&nbsp;  // queue is empty null is returned.
&nbsp;  public T peek() {
<b class="fc">&nbsp;    if (isEmpty()) return null;</b>
<b class="fc">&nbsp;    return heap.get(0);</b>
&nbsp;  }
&nbsp;
&nbsp;  // Removes the root of the heap, O(log(n))
&nbsp;  public T poll() {
<b class="fc">&nbsp;    return removeAt(0);</b>
&nbsp;  }
&nbsp;
&nbsp;  // Test if an element is in heap, O(n)
&nbsp;  public boolean contains(T elem) {
&nbsp;    // Linear scan to check containment
<b class="fc">&nbsp;    for (int i = 0; i &lt; size(); i++) if (heap.get(i).equals(elem)) return true;</b>
<b class="fc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  // Adds an element to the priority queue, the
&nbsp;  // element must not be null, O(log(n))
&nbsp;  public void add(T elem) {
&nbsp;
<b class="fc">&nbsp;    if (elem == null) throw new IllegalArgumentException();</b>
&nbsp;
<b class="fc">&nbsp;    heap.add(elem);</b>
&nbsp;
<b class="fc">&nbsp;    int indexOfLastElem = size() - 1;</b>
<b class="fc">&nbsp;    swim(indexOfLastElem);</b>
&nbsp;  }
&nbsp;
&nbsp;  // Tests if the value of node i &lt;= node j
&nbsp;  // This method assumes i &amp; j are valid indices, O(1)
&nbsp;  private boolean less(int i, int j) {
<b class="fc">&nbsp;    T node1 = heap.get(i);</b>
<b class="fc">&nbsp;    T node2 = heap.get(j);</b>
<b class="fc">&nbsp;    return node1.compareTo(node2) &lt;= 0;</b>
&nbsp;  }
&nbsp;
&nbsp;  // Perform bottom up node swim, O(log(n))
&nbsp;  private void swim(int k) {
&nbsp;
&nbsp;    // Grab the index of the next parent node WRT to k
<b class="fc">&nbsp;    int parent = (k - 1) / 2;</b>
&nbsp;
&nbsp;    // Keep swimming while we have not reached the
&nbsp;    // root and while we&#39;re less than our parent.
<b class="fc">&nbsp;    while (k &gt; 0 &amp;&amp; less(k, parent)) {</b>
&nbsp;      // Exchange k with the parent
<b class="fc">&nbsp;      swap(parent, k);</b>
<b class="fc">&nbsp;      k = parent;</b>
&nbsp;
&nbsp;      // Grab the index of the next parent node WRT to k
<b class="fc">&nbsp;      parent = (k - 1) / 2;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  // Top down node sink, O(log(n))
&nbsp;  private void sink(int k) {
<b class="fc">&nbsp;    int heapSize = size();</b>
&nbsp;    while (true) {
<b class="fc">&nbsp;      int left = 2 * k + 1; // Left  node</b>
<b class="fc">&nbsp;      int right = 2 * k + 2; // Right node</b>
<b class="fc">&nbsp;      int smallest = left; // Assume left is the smallest node of the two children</b>
&nbsp;
&nbsp;      // Find which is smaller left or right
&nbsp;      // If right is smaller set smallest to be right
<b class="fc">&nbsp;      if (right &lt; heapSize &amp;&amp; less(right, left)) smallest = right;</b>
&nbsp;
&nbsp;      // Stop if we&#39;re outside the bounds of the tree
&nbsp;      // or stop early if we cannot sink k anymore
<b class="fc">&nbsp;      if (left &gt;= heapSize || less(k, smallest)) break;</b>
&nbsp;
&nbsp;      // Move down the tree following the smallest node
<b class="fc">&nbsp;      swap(smallest, k);</b>
<b class="fc">&nbsp;      k = smallest;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  // Swap two nodes. Assumes i &amp; j are valid, O(1)
&nbsp;  private void swap(int i, int j) {
<b class="fc">&nbsp;    T elem_i = heap.get(i);</b>
<b class="fc">&nbsp;    T elem_j = heap.get(j);</b>
&nbsp;
<b class="fc">&nbsp;    heap.set(i, elem_j);</b>
<b class="fc">&nbsp;    heap.set(j, elem_i);</b>
&nbsp;  }
&nbsp;
&nbsp;  // Removes a particular element in the heap, O(n)
&nbsp;  public boolean remove(T element) {
<b class="fc">&nbsp;    if (element == null) return false;</b>
&nbsp;    // Linear removal via search, O(n)
<b class="fc">&nbsp;    for (int i = 0; i &lt; size(); i++) {</b>
<b class="fc">&nbsp;      if (element.equals(heap.get(i))) {</b>
<b class="fc">&nbsp;        removeAt(i);</b>
<b class="fc">&nbsp;        return true;</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return false;</b>
&nbsp;  }
&nbsp;
&nbsp;  // Removes a node at particular index, O(log(n))
&nbsp;  private T removeAt(int i) {
<b class="fc">&nbsp;    if (isEmpty()) return null;</b>
&nbsp;
<b class="fc">&nbsp;    int indexOfLastElem = size() - 1;</b>
<b class="fc">&nbsp;    T removed_data = heap.get(i);</b>
<b class="fc">&nbsp;    swap(i, indexOfLastElem);</b>
&nbsp;
&nbsp;    // Obliterate the value
<b class="fc">&nbsp;    heap.remove(indexOfLastElem);</b>
&nbsp;
&nbsp;    // Check if the last element was removed
<b class="fc">&nbsp;    if (i == indexOfLastElem) return removed_data;</b>
<b class="fc">&nbsp;    T elem = heap.get(i);</b>
&nbsp;
&nbsp;    // Try sinking element
<b class="fc">&nbsp;    sink(i);</b>
&nbsp;
&nbsp;    // If sinking did not work try swimming
<b class="fc">&nbsp;    if (heap.get(i).equals(elem)) swim(i);</b>
<b class="fc">&nbsp;    return removed_data;</b>
&nbsp;  }
&nbsp;
&nbsp;  // Recursively checks if this heap is a min heap
&nbsp;  // This method is just for testing purposes to make
&nbsp;  // sure the heap invariant is still being maintained
&nbsp;  // Called this method with k=0 to start at the root
&nbsp;  public boolean isMinHeap(int k) {
&nbsp;    // If we are outside the bounds of the heap return true
<b class="fc">&nbsp;    int heapSize = size();</b>
<b class="fc">&nbsp;    if (k &gt;= heapSize) return true;</b>
&nbsp;
<b class="fc">&nbsp;    int left = 2 * k + 1;</b>
<b class="fc">&nbsp;    int right = 2 * k + 2;</b>
&nbsp;
&nbsp;    // Make sure that the current node k is less than
&nbsp;    // both of its children left, and right if they exist
&nbsp;    // return false otherwise to indicate an invalid heap
<b class="fc">&nbsp;    if (left &lt; heapSize &amp;&amp; !less(k, left)) return false;</b>
<b class="fc">&nbsp;    if (right &lt; heapSize &amp;&amp; !less(k, right)) return false;</b>
&nbsp;
&nbsp;    // Recurse on both children to make sure they&#39;re also valid heaps
<b class="fc">&nbsp;    return isMinHeap(left) &amp;&amp; isMinHeap(right);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public String toString() {
<b class="nc">&nbsp;    return heap.toString();</b>
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-06-22 16:41</div>
</div>
</body>
</html>
